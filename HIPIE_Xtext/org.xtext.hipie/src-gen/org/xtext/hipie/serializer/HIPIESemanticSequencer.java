/*
 * generated by Xtext
 */
package org.xtext.hipie.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.hipie.hIPIE.HIPIEPackage;
import org.xtext.hipie.hIPIE.base_prop;
import org.xtext.hipie.hIPIE.bool;
import org.xtext.hipie.hIPIE.category_type_list;
import org.xtext.hipie.hIPIE.composition_header;
import org.xtext.hipie.hIPIE.contract_instance;
import org.xtext.hipie.hIPIE.custom_section;
import org.xtext.hipie.hIPIE.dataset;
import org.xtext.hipie.hIPIE.ecl_data;
import org.xtext.hipie.hIPIE.ecl_integer;
import org.xtext.hipie.hIPIE.ecl_qstring;
import org.xtext.hipie.hIPIE.ecl_real;
import org.xtext.hipie.hIPIE.ecl_string;
import org.xtext.hipie.hIPIE.ecl_unicode;
import org.xtext.hipie.hIPIE.ecl_unsigned;
import org.xtext.hipie.hIPIE.ecl_varstring;
import org.xtext.hipie.hIPIE.ecl_varunicode;
import org.xtext.hipie.hIPIE.enum_decl;
import org.xtext.hipie.hIPIE.field_decl;
import org.xtext.hipie.hIPIE.function;
import org.xtext.hipie.hIPIE.generate_body;
import org.xtext.hipie.hIPIE.generate_section;
import org.xtext.hipie.hIPIE.group;
import org.xtext.hipie.hIPIE.input_option;
import org.xtext.hipie.hIPIE.input_section;
import org.xtext.hipie.hIPIE.int_var;
import org.xtext.hipie.hIPIE.outfield_decl;
import org.xtext.hipie.hIPIE.output_option;
import org.xtext.hipie.hIPIE.output_section;
import org.xtext.hipie.hIPIE.outputbase;
import org.xtext.hipie.hIPIE.program;
import org.xtext.hipie.hIPIE.record;
import org.xtext.hipie.hIPIE.resource_option;
import org.xtext.hipie.hIPIE.resource_section;
import org.xtext.hipie.hIPIE.string_var;
import org.xtext.hipie.hIPIE.value;
import org.xtext.hipie.hIPIE.vis_basis;
import org.xtext.hipie.hIPIE.visual_multival;
import org.xtext.hipie.hIPIE.visual_option;
import org.xtext.hipie.hIPIE.visual_section;
import org.xtext.hipie.hIPIE.visual_section_option;
import org.xtext.hipie.hIPIE.visualization;
import org.xtext.hipie.services.HIPIEGrammarAccess;

@SuppressWarnings("all")
public class HIPIESemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private HIPIEGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == HIPIEPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case HIPIEPackage.BASE_PROP:
				sequence_base_prop(context, (base_prop) semanticObject); 
				return; 
			case HIPIEPackage.BOOL:
				if(context == grammarAccess.getBoolRule() ||
				   context == grammarAccess.getDatatypeRule() ||
				   context == grammarAccess.getOutfield_declRule()) {
					sequence_bool(context, (bool) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInput_valueRule()) {
					sequence_bool_input_value(context, (bool) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.CATEGORY_TYPE_LIST:
				sequence_category_type_list(context, (category_type_list) semanticObject); 
				return; 
			case HIPIEPackage.COMPOSITION_HEADER:
				sequence_composition_header(context, (composition_header) semanticObject); 
				return; 
			case HIPIEPackage.CONTRACT_INSTANCE:
				sequence_contract_instance(context, (contract_instance) semanticObject); 
				return; 
			case HIPIEPackage.CUSTOM_SECTION:
				sequence_custom_section(context, (custom_section) semanticObject); 
				return; 
			case HIPIEPackage.DATASET:
				if(context == grammarAccess.getDatasetRule() ||
				   context == grammarAccess.getDatatypeRule()) {
					sequence_dataset(context, (dataset) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInput_valueRule()) {
					sequence_dataset_input_value(context, (dataset) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getOutput_valueRule()) {
					sequence_dataset_output_value(context, (dataset) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_DATA:
				if(context == grammarAccess.getEcl_dataRule() ||
				   context == grammarAccess.getEclfield_typeRule()) {
					sequence_ecl_data(context, (ecl_data) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEcloutput_declRule()) {
					sequence_ecl_data_ecloutput_decl(context, (ecl_data) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_INTEGER:
				if(context == grammarAccess.getEcl_integerRule() ||
				   context == grammarAccess.getEclfield_typeRule()) {
					sequence_ecl_integer(context, (ecl_integer) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEcloutput_declRule()) {
					sequence_ecl_integer_ecloutput_decl(context, (ecl_integer) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_QSTRING:
				if(context == grammarAccess.getEcl_qstringRule() ||
				   context == grammarAccess.getEclfield_typeRule()) {
					sequence_ecl_qstring(context, (ecl_qstring) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEcloutput_declRule()) {
					sequence_ecl_qstring_ecloutput_decl(context, (ecl_qstring) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_REAL:
				if(context == grammarAccess.getEcl_realRule() ||
				   context == grammarAccess.getEclfield_typeRule()) {
					sequence_ecl_real(context, (ecl_real) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEcloutput_declRule()) {
					sequence_ecl_real_ecloutput_decl(context, (ecl_real) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_STRING:
				if(context == grammarAccess.getEcl_stringRule() ||
				   context == grammarAccess.getEclfield_typeRule()) {
					sequence_ecl_string(context, (ecl_string) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEcloutput_declRule()) {
					sequence_ecl_string_ecloutput_decl(context, (ecl_string) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_UNICODE:
				if(context == grammarAccess.getEcl_unicodeRule() ||
				   context == grammarAccess.getEclfield_typeRule()) {
					sequence_ecl_unicode(context, (ecl_unicode) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEcloutput_declRule()) {
					sequence_ecl_unicode_ecloutput_decl(context, (ecl_unicode) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_UNSIGNED:
				if(context == grammarAccess.getEcl_unsignedRule() ||
				   context == grammarAccess.getEclfield_typeRule()) {
					sequence_ecl_unsigned(context, (ecl_unsigned) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEcloutput_declRule()) {
					sequence_ecl_unsigned_ecloutput_decl(context, (ecl_unsigned) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_VARSTRING:
				if(context == grammarAccess.getEcl_varstringRule() ||
				   context == grammarAccess.getEclfield_typeRule()) {
					sequence_ecl_varstring(context, (ecl_varstring) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEcloutput_declRule()) {
					sequence_ecl_varstring_ecloutput_decl(context, (ecl_varstring) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_VARUNICODE:
				if(context == grammarAccess.getEcl_varunicodeRule() ||
				   context == grammarAccess.getEclfield_typeRule()) {
					sequence_ecl_varunicode(context, (ecl_varunicode) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEcloutput_declRule()) {
					sequence_ecl_varunicode_ecloutput_decl(context, (ecl_varunicode) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ENUM_DECL:
				if(context == grammarAccess.getEnum_declRule()) {
					sequence_enum_decl(context, (enum_decl) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInput_valueRule()) {
					sequence_enum_decl_input_value(context, (enum_decl) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.FIELD_DECL:
				sequence_field_decl(context, (field_decl) semanticObject); 
				return; 
			case HIPIEPackage.FUNCTION:
				if(context == grammarAccess.getFunctionRule()) {
					sequence_function(context, (function) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getVis_basis_qualifiersRule()) {
					sequence_function_vis_basis_qualifiers(context, (function) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.GENERATE_BODY:
				sequence_generate_body(context, (generate_body) semanticObject); 
				return; 
			case HIPIEPackage.GENERATE_SECTION:
				sequence_generate_section(context, (generate_section) semanticObject); 
				return; 
			case HIPIEPackage.GROUP:
				if(context == grammarAccess.getGroupRule()) {
					sequence_group(context, (group) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInput_valueRule()) {
					sequence_group_input_value(context, (group) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.INPUT_OPTION:
				if(context == grammarAccess.getInput_optionRule()) {
					sequence_input_option(context, (input_option) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInput_optionsRule()) {
					sequence_input_option_input_options(context, (input_option) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.INPUT_SECTION:
				sequence_input_section(context, (input_section) semanticObject); 
				return; 
			case HIPIEPackage.INT_VAR:
				if(context == grammarAccess.getInput_valueRule()) {
					sequence_input_value_int_var(context, (int_var) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getDatatypeRule() ||
				   context == grammarAccess.getInt_varRule() ||
				   context == grammarAccess.getOutfield_declRule()) {
					sequence_int_var(context, (int_var) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.OUTFIELD_DECL:
				sequence_outfield_decl(context, (outfield_decl) semanticObject); 
				return; 
			case HIPIEPackage.OUTPUT_OPTION:
				if(context == grammarAccess.getOutput_optionRule()) {
					sequence_output_option(context, (output_option) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getOutput_optionsRule()) {
					sequence_output_option_output_options(context, (output_option) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.OUTPUT_SECTION:
				sequence_output_section(context, (output_section) semanticObject); 
				return; 
			case HIPIEPackage.OUTPUTBASE:
				sequence_outputbase(context, (outputbase) semanticObject); 
				return; 
			case HIPIEPackage.PROGRAM:
				sequence_program(context, (program) semanticObject); 
				return; 
			case HIPIEPackage.RECORD:
				if(context == grammarAccess.getInput_valueRule()) {
					sequence_input_value_record(context, (record) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getDatatypeRule() ||
				   context == grammarAccess.getRecordRule()) {
					sequence_record(context, (record) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.RESOURCE_OPTION:
				if(context == grammarAccess.getResource_optionRule()) {
					sequence_resource_option(context, (resource_option) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getResource_optionsRule()) {
					sequence_resource_option_resource_options(context, (resource_option) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.RESOURCE_SECTION:
				sequence_resource_section(context, (resource_section) semanticObject); 
				return; 
			case HIPIEPackage.STRING_VAR:
				if(context == grammarAccess.getInput_valueRule()) {
					sequence_input_value_string_var(context, (string_var) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getDatatypeRule() ||
				   context == grammarAccess.getOutfield_declRule() ||
				   context == grammarAccess.getString_varRule()) {
					sequence_string_var(context, (string_var) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.VALUE:
				if(context == grammarAccess.getAssign_listRule()) {
					sequence_assign_assign_list_value(context, (value) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAssignRule()) {
					sequence_assign_value(context, (value) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getOutput_valueRule()) {
					sequence_output_value_value(context, (value) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getResource_valueRule()) {
					sequence_resource_value_value(context, (value) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getCustom_valueRule() ||
				   context == grammarAccess.getFunctionRule() ||
				   context == grammarAccess.getOut_typeRule() ||
				   context == grammarAccess.getValueRule()) {
					sequence_value(context, (value) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getValue_listRule()) {
					sequence_value_value_list(context, (value) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getVis_basis_qualifiersRule()) {
					sequence_value_vis_basis_qualifiers(context, (value) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.VIS_BASIS:
				sequence_vis_basis(context, (vis_basis) semanticObject); 
				return; 
			case HIPIEPackage.VISUAL_MULTIVAL:
				if(context == grammarAccess.getVisual_multivalRule()) {
					sequence_visual_multival(context, (visual_multival) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getVisual_optionRule()) {
					sequence_visual_multival_visual_option(context, (visual_multival) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getVisual_optionsRule()) {
					sequence_visual_multival_visual_option_visual_options(context, (visual_multival) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.VISUAL_OPTION:
				if(context == grammarAccess.getVisual_optionRule()) {
					sequence_visual_option(context, (visual_option) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getVisual_optionsRule()) {
					sequence_visual_option_visual_options(context, (visual_option) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.VISUAL_SECTION:
				sequence_visual_section(context, (visual_section) semanticObject); 
				return; 
			case HIPIEPackage.VISUAL_SECTION_OPTION:
				if(context == grammarAccess.getVisual_section_optionRule()) {
					sequence_visual_section_option(context, (visual_section_option) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getVisual_section_optionsRule()) {
					sequence_visual_section_option_visual_section_options(context, (visual_section_option) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.VISUALIZATION:
				sequence_visualization(context, (visualization) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     ((name=ID | type=INT | name=STRING) vals+=value_list assign_internal+=assign*)
	 */
	protected void sequence_assign_assign_list_value(EObject context, value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=ID | type=INT | name=STRING) vals+=value_list)
	 */
	protected void sequence_assign_value(EObject context, value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 name='NAME' | 
	 *                 name='DESCRIPTION' | 
	 *                 name='AUTHOR' | 
	 *                 name='LICENSE' | 
	 *                 name='COPYRIGHT' | 
	 *                 name='VERSION' | 
	 *                 name='LABEL' | 
	 *                 name='ID'
	 *             ) 
	 *             vals+=value_list
	 *         ) | 
	 *         (name='CATEGORY' cats+=category_type_list)
	 *     )
	 */
	protected void sequence_base_prop(EObject context, base_prop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_bool(EObject context, bool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_ops+=input_options?)
	 */
	protected void sequence_bool_input_value(EObject context, bool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=category_type
	 */
	protected void sequence_category_type_list(EObject context, category_type_list semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HIPIEPackage.Literals.CATEGORY_TYPE_LIST__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HIPIEPackage.Literals.CATEGORY_TYPE_LIST__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCategory_type_listAccess().getNameCategory_typeParserRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name='HEADER' assigns+=assign*)
	 */
	protected void sequence_composition_header(EObject context, composition_header semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='INSTANCE' vals+=value vars+=[value|ID] assigns+=assign*)
	 */
	protected void sequence_contract_instance(EObject context, contract_instance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='CUSTOM' cust_vals+=custom_value*)
	 */
	protected void sequence_custom_section(EObject context, custom_section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_dataset(EObject context, dataset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_ops+=input_options?)
	 */
	protected void sequence_dataset_input_value(EObject context, dataset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID out_base+=outputbase? ops+=output_options? ecl_vars+=ecloutput_decl*)
	 */
	protected void sequence_dataset_output_value(EObject context, dataset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ecl_data(EObject context, ecl_data semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options+=output_options?)
	 */
	protected void sequence_ecl_data_ecloutput_decl(EObject context, ecl_data semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ecl_integer(EObject context, ecl_integer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options+=output_options?)
	 */
	protected void sequence_ecl_integer_ecloutput_decl(EObject context, ecl_integer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ecl_qstring(EObject context, ecl_qstring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options+=output_options?)
	 */
	protected void sequence_ecl_qstring_ecloutput_decl(EObject context, ecl_qstring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ecl_real(EObject context, ecl_real semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options+=output_options?)
	 */
	protected void sequence_ecl_real_ecloutput_decl(EObject context, ecl_real semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ecl_string(EObject context, ecl_string semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options+=output_options?)
	 */
	protected void sequence_ecl_string_ecloutput_decl(EObject context, ecl_string semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ecl_unicode(EObject context, ecl_unicode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options+=output_options?)
	 */
	protected void sequence_ecl_unicode_ecloutput_decl(EObject context, ecl_unicode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ecl_unsigned(EObject context, ecl_unsigned semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options+=output_options?)
	 */
	protected void sequence_ecl_unsigned_ecloutput_decl(EObject context, ecl_unsigned semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ecl_varstring(EObject context, ecl_varstring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options+=output_options?)
	 */
	protected void sequence_ecl_varstring_ecloutput_decl(EObject context, ecl_varstring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ecl_varunicode(EObject context, ecl_varunicode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options+=output_options?)
	 */
	protected void sequence_ecl_varunicode_ecloutput_decl(EObject context, ecl_varunicode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='ENUM' (vals+=value_list | assigns+=assign_list))
	 */
	protected void sequence_enum_decl(EObject context, enum_decl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='ENUM' (vals+=value_list | assigns+=assign_list) input_ops+=input_options?)
	 */
	protected void sequence_enum_decl_input_value(EObject context, enum_decl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_internal+=input_options?)
	 */
	protected void sequence_field_decl(EObject context, field_decl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID | name=ID)
	 */
	protected void sequence_function(EObject context, function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=ID | name=ID) funcs+=function*)
	 */
	protected void sequence_function_vis_basis_qualifiers(EObject context, function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='INLINE' | name='SALT')
	 */
	protected void sequence_generate_body(EObject context, generate_body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='GENERATES' body+=generate_body)
	 */
	protected void sequence_generate_section(EObject context, generate_section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_group(EObject context, group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_internal+=input_options? values+=input_value*)
	 */
	protected void sequence_group_input_value(EObject context, group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='OPTIONAL' | 
	 *         name='DEFINED' | 
	 *         name='DISABLED' | 
	 *         name='MAPBYTYPE' | 
	 *         name='MAPBYNAME' | 
	 *         name='MANY' | 
	 *         name='FORMFIELD' | 
	 *         (name='ENABLE' assigns_internal+=assign_list) | 
	 *         name='TYPE' | 
	 *         (
	 *             (
	 *                 name='RANGE' | 
	 *                 name='DEFAULT' | 
	 *                 name='MAXLENGTH' | 
	 *                 name='DISABLED' | 
	 *                 name='DESCRIPTION' | 
	 *                 name='NULL' | 
	 *                 name='FIELDLENGTH' | 
	 *                 name='ROWS' | 
	 *                 name='COLS' | 
	 *                 name='_HTML_STYLECLASS' | 
	 *                 name='LABEL'
	 *             ) 
	 *             vals+=value_list
	 *         )
	 *     )
	 */
	protected void sequence_input_option(EObject context, input_option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             name='OPTIONAL' | 
	 *             name='DEFINED' | 
	 *             name='DISABLED' | 
	 *             name='MAPBYTYPE' | 
	 *             name='MAPBYNAME' | 
	 *             name='MANY' | 
	 *             name='FORMFIELD' | 
	 *             (name='ENABLE' assigns_internal+=assign_list) | 
	 *             name='TYPE' | 
	 *             (
	 *                 (
	 *                     name='RANGE' | 
	 *                     name='DEFAULT' | 
	 *                     name='MAXLENGTH' | 
	 *                     name='DISABLED' | 
	 *                     name='DESCRIPTION' | 
	 *                     name='NULL' | 
	 *                     name='FIELDLENGTH' | 
	 *                     name='ROWS' | 
	 *                     name='COLS' | 
	 *                     name='_HTML_STYLECLASS' | 
	 *                     name='LABEL'
	 *                 ) 
	 *                 vals+=value_list
	 *             )
	 *         ) 
	 *         input_internal+=input_option*
	 *     )
	 */
	protected void sequence_input_option_input_options(EObject context, input_option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='INPUTS' inputs+=input_value+)
	 */
	protected void sequence_input_section(EObject context, input_section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_ops+=input_options?)
	 */
	protected void sequence_input_value_int_var(EObject context, int_var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_ops+=input_options?)
	 */
	protected void sequence_input_value_record(EObject context, record semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_ops+=input_options?)
	 */
	protected void sequence_input_value_string_var(EObject context, string_var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_int_var(EObject context, int_var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     fields+=field_decl
	 */
	protected void sequence_outfield_decl(EObject context, outfield_decl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='SIDE' | 
	 *         name='LARGE' | 
	 *         name='SMALL' | 
	 *         name='FEW' | 
	 *         name='WUID' | 
	 *         (name='FROM' vars+=[datatype|ID]) | 
	 *         (name='DESCRIPTION' vals+=value)
	 *     )
	 */
	protected void sequence_output_option(EObject context, output_option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             name='SIDE' | 
	 *             name='LARGE' | 
	 *             name='SMALL' | 
	 *             name='FEW' | 
	 *             name='WUID' | 
	 *             (name='FROM' vars+=[datatype|ID]) | 
	 *             (name='DESCRIPTION' vals+=value)
	 *         ) 
	 *         output_internal+=output_option*
	 *     )
	 */
	protected void sequence_output_option_output_options(EObject context, output_option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='OUTPUTS' outputs+=output_value+)
	 */
	protected void sequence_output_section(EObject context, output_section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=ID | type=INT | name=STRING) ops+=output_options?)
	 */
	protected void sequence_output_value_value(EObject context, value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     actions=[dataset|ID]
	 */
	protected void sequence_outputbase(EObject context, outputbase semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HIPIEPackage.Literals.OUTPUTBASE__ACTIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HIPIEPackage.Literals.OUTPUTBASE__ACTIONS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOutputbaseAccess().getActionsDatasetIDTerminalRuleCall_1_0_1(), semanticObject.getActions());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         Composition_Header+=composition_header? 
	 *         Base_Props+=base_prop+ 
	 *         Contract_Instances+=contract_instance* 
	 *         Input_Section+=input_section? 
	 *         Output_Section+=output_section? 
	 *         Visual_Section+=visual_section* 
	 *         Generate_Section+=generate_section? 
	 *         Custom_Section+=custom_section? 
	 *         Resource_Section+=resource_section?
	 *     )
	 */
	protected void sequence_program(EObject context, program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_record(EObject context, record semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name='DESCRIPTION' | name='FILE' | name='LABEL' | name='_HTML_STYLECLASS') vals+=value)
	 */
	protected void sequence_resource_option(EObject context, resource_option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name='DESCRIPTION' | name='FILE' | name='LABEL' | name='_HTML_STYLECLASS') vals+=value res_ops+=resource_option*)
	 */
	protected void sequence_resource_option_resource_options(EObject context, resource_option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='RESOURCES' res_vals+=resource_value+)
	 */
	protected void sequence_resource_section(EObject context, resource_section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=ID | type=INT | name=STRING) res_ops+=resource_options?)
	 */
	protected void sequence_resource_value_value(EObject context, value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_string_var(EObject context, string_var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID | type=INT | name=STRING)
	 */
	protected void sequence_value(EObject context, value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=ID | type=INT | name=STRING) vals+=value*)
	 */
	protected void sequence_value_value_list(EObject context, value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=ID | type=INT | name=STRING) funcs+=function*)
	 */
	protected void sequence_value_vis_basis_qualifiers(EObject context, value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (vars+=[dataset|ID] quals+=vis_basis_qualifiers?)
	 */
	protected void sequence_vis_basis(EObject context, vis_basis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='X' | 
	 *         name='Y' | 
	 *         name='COLOR' | 
	 *         name='RANGE' | 
	 *         name='FILTER' | 
	 *         name='LABEL' | 
	 *         name='VALUE'
	 *     )
	 */
	protected void sequence_visual_multival(EObject context, visual_multival semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             name='X' | 
	 *             name='Y' | 
	 *             name='COLOR' | 
	 *             name='RANGE' | 
	 *             name='FILTER' | 
	 *             name='LABEL' | 
	 *             name='VALUE'
	 *         ) 
	 *         funcs+=function 
	 *         funcs+=function*
	 *     )
	 */
	protected void sequence_visual_multival_visual_option(EObject context, visual_multival semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             name='X' | 
	 *             name='Y' | 
	 *             name='COLOR' | 
	 *             name='RANGE' | 
	 *             name='FILTER' | 
	 *             name='LABEL' | 
	 *             name='VALUE'
	 *         ) 
	 *         funcs+=function 
	 *         funcs+=function* 
	 *         vis_ops+=visual_option*
	 *     )
	 */
	protected void sequence_visual_multival_visual_option_visual_options(EObject context, visual_multival semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 name='TITLE' | 
	 *                 name='DATE' | 
	 *                 name='DESCRIPTION' | 
	 *                 name='PICTURE' | 
	 *                 name='STATE' | 
	 *                 name='COUNTY' | 
	 *                 name='WEIGHT' | 
	 *                 name='SIZE'
	 *             ) 
	 *             funcs+=function
	 *         ) | 
	 *         name='SELECTS'
	 *     )
	 */
	protected void sequence_visual_option(EObject context, visual_option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 (
	 *                     name='TITLE' | 
	 *                     name='DATE' | 
	 *                     name='DESCRIPTION' | 
	 *                     name='PICTURE' | 
	 *                     name='STATE' | 
	 *                     name='COUNTY' | 
	 *                     name='WEIGHT' | 
	 *                     name='SIZE'
	 *                 ) 
	 *                 funcs+=function
	 *             ) | 
	 *             name='SELECTS'
	 *         ) 
	 *         vis_ops+=visual_option*
	 *     )
	 */
	protected void sequence_visual_option_visual_options(EObject context, visual_option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='LABEL' vals+=value)
	 */
	protected void sequence_visual_section_option(EObject context, visual_section_option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='LABEL' vals+=value vis_ops+=visual_section_option*)
	 */
	protected void sequence_visual_section_option_visual_section_options(EObject context, visual_section_option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='VISUALIZE' vis_ops+=visual_section_options? vis_elements+=visualization+)
	 */
	protected void sequence_visual_section(EObject context, visual_section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=ID inputs+=vis_basis vis_ops+=visual_options?) | (name=ID vis_ops+=visual_options?))
	 */
	protected void sequence_visualization(EObject context, visualization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}

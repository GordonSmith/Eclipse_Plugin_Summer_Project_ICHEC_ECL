/*
 * generated by Xtext
 */
package org.xtext.hipie.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.hipie.hIPIE.Assign;
import org.xtext.hipie.hIPIE.AssignList;
import org.xtext.hipie.hIPIE.BaseProp;
import org.xtext.hipie.hIPIE.Bool;
import org.xtext.hipie.hIPIE.CategoryTypeList;
import org.xtext.hipie.hIPIE.CompositionHeader;
import org.xtext.hipie.hIPIE.ContractInstance;
import org.xtext.hipie.hIPIE.CustomSection;
import org.xtext.hipie.hIPIE.Dataset;
import org.xtext.hipie.hIPIE.ECLData;
import org.xtext.hipie.hIPIE.ECLInteger;
import org.xtext.hipie.hIPIE.ECLQstring;
import org.xtext.hipie.hIPIE.ECLReal;
import org.xtext.hipie.hIPIE.ECLString;
import org.xtext.hipie.hIPIE.ECLUnicode;
import org.xtext.hipie.hIPIE.ECLUnsigned;
import org.xtext.hipie.hIPIE.ECLVarstring;
import org.xtext.hipie.hIPIE.ECLVarunicode;
import org.xtext.hipie.hIPIE.EnumDecl;
import org.xtext.hipie.hIPIE.FieldDecl;
import org.xtext.hipie.hIPIE.Function;
import org.xtext.hipie.hIPIE.GenerateBodyInline;
import org.xtext.hipie.hIPIE.GenerateBodySalt;
import org.xtext.hipie.hIPIE.Group;
import org.xtext.hipie.hIPIE.HIPIEPackage;
import org.xtext.hipie.hIPIE.InputOption;
import org.xtext.hipie.hIPIE.InputOptions;
import org.xtext.hipie.hIPIE.InputSection;
import org.xtext.hipie.hIPIE.IntVar;
import org.xtext.hipie.hIPIE.OutDataset;
import org.xtext.hipie.hIPIE.OutType;
import org.xtext.hipie.hIPIE.OutfieldDecl;
import org.xtext.hipie.hIPIE.OutputBase;
import org.xtext.hipie.hIPIE.OutputOption;
import org.xtext.hipie.hIPIE.OutputOptions;
import org.xtext.hipie.hIPIE.OutputSection;
import org.xtext.hipie.hIPIE.Program;
import org.xtext.hipie.hIPIE.Record;
import org.xtext.hipie.hIPIE.ResourceOption;
import org.xtext.hipie.hIPIE.ResourceOptions;
import org.xtext.hipie.hIPIE.ResourceSection;
import org.xtext.hipie.hIPIE.StringVar;
import org.xtext.hipie.hIPIE.Value;
import org.xtext.hipie.hIPIE.ValueList;
import org.xtext.hipie.hIPIE.VisBasis;
import org.xtext.hipie.hIPIE.VisBasisQualifiers;
import org.xtext.hipie.hIPIE.VisualMultival;
import org.xtext.hipie.hIPIE.VisualOption;
import org.xtext.hipie.hIPIE.VisualOptions;
import org.xtext.hipie.hIPIE.VisualSection;
import org.xtext.hipie.hIPIE.VisualSectionOption;
import org.xtext.hipie.hIPIE.VisualSectionOptions;
import org.xtext.hipie.hIPIE.Visualization;
import org.xtext.hipie.services.HIPIEGrammarAccess;

@SuppressWarnings("all")
public class HIPIESemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private HIPIEGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == HIPIEPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case HIPIEPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case HIPIEPackage.ASSIGN_LIST:
				sequence_AssignList(context, (AssignList) semanticObject); 
				return; 
			case HIPIEPackage.BASE_PROP:
				sequence_BaseProp(context, (BaseProp) semanticObject); 
				return; 
			case HIPIEPackage.BOOL:
				if(context == grammarAccess.getBoolRule() ||
				   context == grammarAccess.getDatatypeRule() ||
				   context == grammarAccess.getOutfieldDeclRule()) {
					sequence_Bool(context, (Bool) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInputValueRule()) {
					sequence_Bool_InputValue(context, (Bool) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.CATEGORY_TYPE_LIST:
				sequence_CategoryTypeList(context, (CategoryTypeList) semanticObject); 
				return; 
			case HIPIEPackage.COMPOSITION_HEADER:
				sequence_CompositionHeader(context, (CompositionHeader) semanticObject); 
				return; 
			case HIPIEPackage.CONTRACT_INSTANCE:
				sequence_ContractInstance(context, (ContractInstance) semanticObject); 
				return; 
			case HIPIEPackage.CUSTOM_SECTION:
				sequence_CustomSection(context, (CustomSection) semanticObject); 
				return; 
			case HIPIEPackage.DATASET:
				if(context == grammarAccess.getDatasetRule() ||
				   context == grammarAccess.getDatatypeRule()) {
					sequence_Dataset(context, (Dataset) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInputValueRule()) {
					sequence_Dataset_InputValue(context, (Dataset) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_DATA:
				if(context == grammarAccess.getECLDataRule() ||
				   context == grammarAccess.getECLfieldTypeRule() ||
				   context == grammarAccess.getPosVizDataRule()) {
					sequence_ECLData(context, (ECLData) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getECLOutputDeclRule()) {
					sequence_ECLData_ECLOutputDecl(context, (ECLData) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_INTEGER:
				if(context == grammarAccess.getECLIntegerRule() ||
				   context == grammarAccess.getECLfieldTypeRule() ||
				   context == grammarAccess.getPosVizDataRule()) {
					sequence_ECLInteger(context, (ECLInteger) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getECLOutputDeclRule()) {
					sequence_ECLInteger_ECLOutputDecl(context, (ECLInteger) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_QSTRING:
				if(context == grammarAccess.getECLOutputDeclRule()) {
					sequence_ECLOutputDecl_ECLQstring(context, (ECLQstring) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getECLQstringRule() ||
				   context == grammarAccess.getECLfieldTypeRule() ||
				   context == grammarAccess.getPosVizDataRule()) {
					sequence_ECLQstring(context, (ECLQstring) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_REAL:
				if(context == grammarAccess.getECLOutputDeclRule()) {
					sequence_ECLOutputDecl_ECLReal(context, (ECLReal) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getECLRealRule() ||
				   context == grammarAccess.getECLfieldTypeRule() ||
				   context == grammarAccess.getPosVizDataRule()) {
					sequence_ECLReal(context, (ECLReal) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_STRING:
				if(context == grammarAccess.getECLOutputDeclRule()) {
					sequence_ECLOutputDecl_ECLString(context, (ECLString) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getECLStringRule() ||
				   context == grammarAccess.getECLfieldTypeRule() ||
				   context == grammarAccess.getPosVizDataRule()) {
					sequence_ECLString(context, (ECLString) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_UNICODE:
				if(context == grammarAccess.getECLOutputDeclRule()) {
					sequence_ECLOutputDecl_ECLUnicode(context, (ECLUnicode) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getECLUnicodeRule() ||
				   context == grammarAccess.getECLfieldTypeRule() ||
				   context == grammarAccess.getPosVizDataRule()) {
					sequence_ECLUnicode(context, (ECLUnicode) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_UNSIGNED:
				if(context == grammarAccess.getECLOutputDeclRule()) {
					sequence_ECLOutputDecl_ECLUnsigned(context, (ECLUnsigned) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getECLUnsignedRule() ||
				   context == grammarAccess.getECLfieldTypeRule() ||
				   context == grammarAccess.getPosVizDataRule()) {
					sequence_ECLUnsigned(context, (ECLUnsigned) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_VARSTRING:
				if(context == grammarAccess.getECLOutputDeclRule()) {
					sequence_ECLOutputDecl_ECLVarstring(context, (ECLVarstring) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getECLVarstringRule() ||
				   context == grammarAccess.getECLfieldTypeRule() ||
				   context == grammarAccess.getPosVizDataRule()) {
					sequence_ECLVarstring(context, (ECLVarstring) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ECL_VARUNICODE:
				if(context == grammarAccess.getECLOutputDeclRule()) {
					sequence_ECLOutputDecl_ECLVarunicode(context, (ECLVarunicode) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getECLVarunicodeRule() ||
				   context == grammarAccess.getECLfieldTypeRule() ||
				   context == grammarAccess.getPosVizDataRule()) {
					sequence_ECLVarunicode(context, (ECLVarunicode) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.ENUM_DECL:
				if(context == grammarAccess.getEnumDeclRule()) {
					sequence_EnumDecl(context, (EnumDecl) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInputValueRule()) {
					sequence_EnumDecl_InputValue(context, (EnumDecl) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.FIELD_DECL:
				sequence_FieldDecl(context, (FieldDecl) semanticObject); 
				return; 
			case HIPIEPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case HIPIEPackage.GENERATE_BODY_INLINE:
				sequence_GenerateBodyInline(context, (GenerateBodyInline) semanticObject); 
				return; 
			case HIPIEPackage.GENERATE_BODY_SALT:
				sequence_GenerateBodySalt(context, (GenerateBodySalt) semanticObject); 
				return; 
			case HIPIEPackage.GROUP:
				if(context == grammarAccess.getGroupRule()) {
					sequence_Group(context, (Group) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInputValueRule()) {
					sequence_Group_InputValue(context, (Group) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.INPUT_OPTION:
				sequence_InputOption(context, (InputOption) semanticObject); 
				return; 
			case HIPIEPackage.INPUT_OPTIONS:
				sequence_InputOptions(context, (InputOptions) semanticObject); 
				return; 
			case HIPIEPackage.INPUT_SECTION:
				sequence_InputSection(context, (InputSection) semanticObject); 
				return; 
			case HIPIEPackage.INT_VAR:
				if(context == grammarAccess.getInputValueRule()) {
					sequence_InputValue_IntVar(context, (IntVar) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getDatatypeRule() ||
				   context == grammarAccess.getIntVarRule() ||
				   context == grammarAccess.getOutfieldDeclRule()) {
					sequence_IntVar(context, (IntVar) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.OUT_DATASET:
				if(context == grammarAccess.getOutDatasetRule()) {
					sequence_OutDataset(context, (OutDataset) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getOutputValueRule()) {
					sequence_OutDataset_OutputValue(context, (OutDataset) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.OUT_TYPE:
				if(context == grammarAccess.getOutTypeRule()) {
					sequence_OutType(context, (OutType) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getOutputValueRule()) {
					sequence_OutType_OutputValue(context, (OutType) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.OUTFIELD_DECL:
				sequence_OutfieldDecl(context, (OutfieldDecl) semanticObject); 
				return; 
			case HIPIEPackage.OUTPUT_BASE:
				sequence_OutputBase(context, (OutputBase) semanticObject); 
				return; 
			case HIPIEPackage.OUTPUT_OPTION:
				sequence_OutputOption(context, (OutputOption) semanticObject); 
				return; 
			case HIPIEPackage.OUTPUT_OPTIONS:
				sequence_OutputOptions(context, (OutputOptions) semanticObject); 
				return; 
			case HIPIEPackage.OUTPUT_SECTION:
				sequence_OutputSection(context, (OutputSection) semanticObject); 
				return; 
			case HIPIEPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case HIPIEPackage.RECORD:
				if(context == grammarAccess.getInputValueRule()) {
					sequence_InputValue_Record(context, (Record) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getDatatypeRule() ||
				   context == grammarAccess.getRecordRule()) {
					sequence_Record(context, (Record) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.RESOURCE_OPTION:
				sequence_ResourceOption(context, (ResourceOption) semanticObject); 
				return; 
			case HIPIEPackage.RESOURCE_OPTIONS:
				sequence_ResourceOptions(context, (ResourceOptions) semanticObject); 
				return; 
			case HIPIEPackage.RESOURCE_SECTION:
				sequence_ResourceSection(context, (ResourceSection) semanticObject); 
				return; 
			case HIPIEPackage.STRING_VAR:
				if(context == grammarAccess.getInputValueRule()) {
					sequence_InputValue_StringVar(context, (StringVar) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getDatatypeRule() ||
				   context == grammarAccess.getOutfieldDeclRule() ||
				   context == grammarAccess.getStringVarRule()) {
					sequence_StringVar(context, (StringVar) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.VALUE:
				if(context == grammarAccess.getResourceValueRule()) {
					sequence_ResourceValue_Value(context, (Value) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getCustomValueRule() ||
				   context == grammarAccess.getValueRule()) {
					sequence_Value(context, (Value) semanticObject); 
					return; 
				}
				else break;
			case HIPIEPackage.VALUE_LIST:
				sequence_ValueList(context, (ValueList) semanticObject); 
				return; 
			case HIPIEPackage.VIS_BASIS:
				sequence_VisBasis(context, (VisBasis) semanticObject); 
				return; 
			case HIPIEPackage.VIS_BASIS_QUALIFIERS:
				sequence_VisBasisQualifiers(context, (VisBasisQualifiers) semanticObject); 
				return; 
			case HIPIEPackage.VISUAL_MULTIVAL:
				sequence_VisualMultival(context, (VisualMultival) semanticObject); 
				return; 
			case HIPIEPackage.VISUAL_OPTION:
				sequence_VisualOption(context, (VisualOption) semanticObject); 
				return; 
			case HIPIEPackage.VISUAL_OPTIONS:
				sequence_VisualOptions(context, (VisualOptions) semanticObject); 
				return; 
			case HIPIEPackage.VISUAL_SECTION:
				sequence_VisualSection(context, (VisualSection) semanticObject); 
				return; 
			case HIPIEPackage.VISUAL_SECTION_OPTION:
				sequence_VisualSectionOption(context, (VisualSectionOption) semanticObject); 
				return; 
			case HIPIEPackage.VISUAL_SECTION_OPTIONS:
				sequence_VisualSectionOptions(context, (VisualSectionOptions) semanticObject); 
				return; 
			case HIPIEPackage.VISUALIZATION:
				sequence_Visualization(context, (Visualization) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (assigns+=Assign assigns+=Assign*)
	 */
	protected void sequence_AssignList(EObject context, AssignList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID vals=ValueList)
	 */
	protected void sequence_Assign(EObject context, Assign semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HIPIEPackage.Literals.ASSIGN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HIPIEPackage.Literals.ASSIGN__NAME));
			if(transientValues.isValueTransient(semanticObject, HIPIEPackage.Literals.ASSIGN__VALS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HIPIEPackage.Literals.ASSIGN__VALS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssignAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAssignAccess().getValsValueListParserRuleCall_2_0(), semanticObject.getVals());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 name='NAME' | 
	 *                 name='DESCRIPTION' | 
	 *                 name='AUTHOR' | 
	 *                 name='LICENSE' | 
	 *                 name='COPYRIGHT' | 
	 *                 name='VERSION' | 
	 *                 name='LABEL' | 
	 *                 name='ID'
	 *             ) 
	 *             val_list=ValueList
	 *         ) | 
	 *         (name='CATEGORY' cat_list=CategoryTypeList)
	 *     )
	 */
	protected void sequence_BaseProp(EObject context, BaseProp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Bool(EObject context, Bool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_op_list=InputOptions?)
	 */
	protected void sequence_Bool_InputValue(EObject context, Bool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (cats+=CategoryType cats+=CategoryType*)
	 */
	protected void sequence_CategoryTypeList(EObject context, CategoryTypeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='HEADER' assigns+=Assign*)
	 */
	protected void sequence_CompositionHeader(EObject context, CompositionHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sec_name='INSTANCE' vals+=Value vars+=[Value|ID] assigns+=Assign*)
	 */
	protected void sequence_ContractInstance(EObject context, ContractInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='CUSTOM' cust_vals+=CustomValue*)
	 */
	protected void sequence_CustomSection(EObject context, CustomSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Dataset(EObject context, Dataset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_op_list=InputOptions?)
	 */
	protected void sequence_Dataset_InputValue(EObject context, Dataset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ECLData(EObject context, ECLData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options=OutputOptions?)
	 */
	protected void sequence_ECLData_ECLOutputDecl(EObject context, ECLData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ECLInteger(EObject context, ECLInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options=OutputOptions?)
	 */
	protected void sequence_ECLInteger_ECLOutputDecl(EObject context, ECLInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options=OutputOptions?)
	 */
	protected void sequence_ECLOutputDecl_ECLQstring(EObject context, ECLQstring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options=OutputOptions?)
	 */
	protected void sequence_ECLOutputDecl_ECLReal(EObject context, ECLReal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options=OutputOptions?)
	 */
	protected void sequence_ECLOutputDecl_ECLString(EObject context, ECLString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options=OutputOptions?)
	 */
	protected void sequence_ECLOutputDecl_ECLUnicode(EObject context, ECLUnicode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options=OutputOptions?)
	 */
	protected void sequence_ECLOutputDecl_ECLUnsigned(EObject context, ECLUnsigned semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options=OutputOptions?)
	 */
	protected void sequence_ECLOutputDecl_ECLVarstring(EObject context, ECLVarstring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID options=OutputOptions?)
	 */
	protected void sequence_ECLOutputDecl_ECLVarunicode(EObject context, ECLVarunicode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ECLQstring(EObject context, ECLQstring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ECLReal(EObject context, ECLReal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ECLString(EObject context, ECLString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ECLUnicode(EObject context, ECLUnicode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ECLUnsigned(EObject context, ECLUnsigned semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ECLVarstring(EObject context, ECLVarstring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ECLVarunicode(EObject context, ECLVarunicode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (enum_dec='ENUM' (vals+=ValueList | assigns+=AssignList))
	 */
	protected void sequence_EnumDecl(EObject context, EnumDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (enum_dec='ENUM' (vals+=ValueList | assigns+=AssignList) input_op_list=InputOptions?)
	 */
	protected void sequence_EnumDecl_InputValue(EObject context, EnumDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_ops=InputOptions?)
	 */
	protected void sequence_FieldDecl(EObject context, FieldDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         vars=[PosVizData|ID] | 
	 *         vals=Value | 
	 *         vars=[PosVizData|ID] | 
	 *         vals=Value | 
	 *         vars=[PosVizData|ID] | 
	 *         vals=Value
	 *     )
	 */
	protected void sequence_Function(EObject context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name='GENERATES'
	 */
	protected void sequence_GenerateBodyInline(EObject context, GenerateBodyInline semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HIPIEPackage.Literals.GENERATE_SECTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HIPIEPackage.Literals.GENERATE_SECTION__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGenerateBodyInlineAccess().getNameGENERATESKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name='GENERATES'
	 */
	protected void sequence_GenerateBodySalt(EObject context, GenerateBodySalt semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HIPIEPackage.Literals.GENERATE_SECTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HIPIEPackage.Literals.GENERATE_SECTION__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGenerateBodySaltAccess().getNameGENERATESKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Group(EObject context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_op_list=InputOptions? vals+=InputValue*)
	 */
	protected void sequence_Group_InputValue(EObject context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='OPTIONAL' | 
	 *         name='DEFINED' | 
	 *         name='DISABLED' | 
	 *         name='MAPBYTYPE' | 
	 *         name='MAPBYNAME' | 
	 *         name='MANY' | 
	 *         name='FORMFIELD' | 
	 *         (name='ENABLE' assigns_list=AssignList) | 
	 *         name='TYPE' | 
	 *         (
	 *             (
	 *                 name='RANGE' | 
	 *                 name='DEFAULT' | 
	 *                 name='MAXLENGTH' | 
	 *                 name='DISABLED' | 
	 *                 name='DESCRIPTION' | 
	 *                 name='NULL' | 
	 *                 name='FIELDLENGTH' | 
	 *                 name='ROWS' | 
	 *                 name='COLS' | 
	 *                 name='_HTML_STYLECLASS' | 
	 *                 name='LABEL'
	 *             ) 
	 *             vals+=ValueList
	 *         )
	 *     )
	 */
	protected void sequence_InputOption(EObject context, InputOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (input_ops+=InputOption input_ops+=InputOption*)
	 */
	protected void sequence_InputOptions(EObject context, InputOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='INPUTS' inputs+=InputValue+)
	 */
	protected void sequence_InputSection(EObject context, InputSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_op_list=InputOptions?)
	 */
	protected void sequence_InputValue_IntVar(EObject context, IntVar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_op_list=InputOptions?)
	 */
	protected void sequence_InputValue_Record(EObject context, Record semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID input_op_list=InputOptions?)
	 */
	protected void sequence_InputValue_StringVar(EObject context, StringVar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_IntVar(EObject context, IntVar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID out_base=OutputBase? ops+=OutputOptions?)
	 */
	protected void sequence_OutDataset(EObject context, OutDataset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID out_base=OutputBase? ops+=OutputOptions? ecl_vars+=ECLOutputDecl*)
	 */
	protected void sequence_OutDataset_OutputValue(EObject context, OutDataset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=Value
	 */
	protected void sequence_OutType(EObject context, OutType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (val=Value ops=OutputOptions?)
	 */
	protected void sequence_OutType_OutputValue(EObject context, OutType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     fields+=FieldDecl
	 */
	protected void sequence_OutfieldDecl(EObject context, OutfieldDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     base=[Datatype|ID]
	 */
	protected void sequence_OutputBase(EObject context, OutputBase semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HIPIEPackage.Literals.OUTPUT_BASE__BASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HIPIEPackage.Literals.OUTPUT_BASE__BASE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOutputBaseAccess().getBaseDatatypeIDTerminalRuleCall_1_0_1(), semanticObject.getBase());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='SIDE' | 
	 *         name='LARGE' | 
	 *         name='SMALL' | 
	 *         name='FEW' | 
	 *         name='WUID' | 
	 *         (name='FROM' vars=[Datatype|ID]) | 
	 *         (name='DESCRIPTION' vals=Value)
	 *     )
	 */
	protected void sequence_OutputOption(EObject context, OutputOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (output_ops+=OutputOption output_ops+=OutputOption*)
	 */
	protected void sequence_OutputOptions(EObject context, OutputOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='OUTPUTS' outputs+=OutputValue+)
	 */
	protected void sequence_OutputSection(EObject context, OutputSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         composition_header+=CompositionHeader? 
	 *         base_props+=BaseProp+ 
	 *         contract_instances+=ContractInstance* 
	 *         input_section+=InputSection? 
	 *         output_section+=OutputSection? 
	 *         visual_section+=VisualSection* 
	 *         generate_section+=GenerateSection? 
	 *         custom_section+=CustomSection? 
	 *         sesource_section+=ResourceSection?
	 *     )
	 */
	protected void sequence_Program(EObject context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Record(EObject context, Record semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name='DESCRIPTION' | name='FILE' | name='LABEL' | name='_HTML_STYLECLASS') vals=Value)
	 */
	protected void sequence_ResourceOption(EObject context, ResourceOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (res_ops+=ResourceOption res_ops+=ResourceOption*)
	 */
	protected void sequence_ResourceOptions(EObject context, ResourceOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='RESOURCES' res_vals+=ResourceValue+)
	 */
	protected void sequence_ResourceSection(EObject context, ResourceSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=ID | int_val=INT | str_val=STRING) res_ops=ResourceOptions?)
	 */
	protected void sequence_ResourceValue_Value(EObject context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_StringVar(EObject context, StringVar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (vals+=Value vals+=Value*)
	 */
	protected void sequence_ValueList(EObject context, ValueList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID | int_val=INT | str_val=STRING)
	 */
	protected void sequence_Value(EObject context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (funcs+=Function funcs+=Function*)
	 */
	protected void sequence_VisBasisQualifiers(EObject context, VisBasisQualifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (basis=[OutDataset|ID] quals=VisBasisQualifiers?)
	 */
	protected void sequence_VisBasis(EObject context, VisBasis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='X' | 
	 *         name='Y' | 
	 *         name='COLOR' | 
	 *         name='RANGE' | 
	 *         name='FILTER' | 
	 *         name='LABEL' | 
	 *         name='VALUE'
	 *     )
	 */
	protected void sequence_VisualMultival(EObject context, VisualMultival semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 name='TITLE' | 
	 *                 name='DATE' | 
	 *                 name='DESCRIPTION' | 
	 *                 name='PICTURE' | 
	 *                 name='STATE' | 
	 *                 name='COUNTY' | 
	 *                 name='WEIGHT' | 
	 *                 name='SIZE'
	 *             ) 
	 *             funcs+=Function
	 *         ) | 
	 *         (vis_mult=VisualMultival funcs+=Function funcs+=Function*) | 
	 *         name='SELECTS'
	 *     )
	 */
	protected void sequence_VisualOption(EObject context, VisualOption semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (vis_ops+=VisualOption vis_ops+=VisualOption*)
	 */
	protected void sequence_VisualOptions(EObject context, VisualOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='LABEL' vals=Value)
	 */
	protected void sequence_VisualSectionOption(EObject context, VisualSectionOption semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, HIPIEPackage.Literals.VISUAL_SECTION_OPTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HIPIEPackage.Literals.VISUAL_SECTION_OPTION__NAME));
			if(transientValues.isValueTransient(semanticObject, HIPIEPackage.Literals.VISUAL_SECTION_OPTION__VALS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HIPIEPackage.Literals.VISUAL_SECTION_OPTION__VALS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVisualSectionOptionAccess().getNameLABELKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVisualSectionOptionAccess().getValsValueParserRuleCall_2_0(), semanticObject.getVals());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (vis_ops+=VisualSectionOption vis_ops+=VisualSectionOption*)
	 */
	protected void sequence_VisualSectionOptions(EObject context, VisualSectionOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sec_name='VISUALIZE' vis_ops=VisualSectionOptions? vis_elements+=Visualization+)
	 */
	protected void sequence_VisualSection(EObject context, VisualSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=ID input=VisBasis vis_op=VisualOptions?) | (name=ID vis_op=VisualOptions?))
	 */
	protected void sequence_Visualization(EObject context, Visualization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}

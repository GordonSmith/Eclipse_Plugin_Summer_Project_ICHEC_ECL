/**
 * generated by Xtext
 */
package org.xtext.hipie.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.MapBasedScope;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.xtext.hipie.hIPIE.InputSection;
import org.xtext.hipie.hIPIE.OutputSection;
import org.xtext.hipie.hIPIE.VisBasis;
import org.xtext.hipie.hIPIE.VisualSection;
import org.xtext.hipie.hIPIE.dataset;
import org.xtext.hipie.hIPIE.out_dataset;
import org.xtext.hipie.hIPIE.outputbase;
import org.xtext.hipie.hIPIE.vis_basis_qualifiers;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class HIPIEScopeProvider extends AbstractDeclarativeScopeProvider {
  public IScope scope_outputbase_actions(final OutputSection context, final EReference ref) {
    final EObject parent = EcoreUtil.getRootContainer(context);
    EList<EObject> _eContents = parent.eContents();
    int _length = ((Object[])Conversions.unwrapArray(_eContents, Object.class)).length;
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length, true);
    for (final Integer i : _doubleDotLessThan) {
      EList<EObject> _eContents_1 = parent.eContents();
      EObject _get = _eContents_1.get((i).intValue());
      if ((_get instanceof InputSection)) {
        EList<EObject> _eContents_2 = parent.eContents();
        EObject _get_1 = _eContents_2.get((i).intValue());
        return this.getScope(_get_1, ref);
      }
    }
    return null;
  }
  
  public IScope scope_VisBasis_assigned(final VisualSection context, final EReference ref) {
    final EObject parent = EcoreUtil.getRootContainer(context);
    EList<EObject> _eContents = parent.eContents();
    int _length = ((Object[])Conversions.unwrapArray(_eContents, Object.class)).length;
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _length, true);
    for (final Integer i : _doubleDotLessThan) {
      EList<EObject> _eContents_1 = parent.eContents();
      EObject _get = _eContents_1.get((i).intValue());
      if ((_get instanceof OutputSection)) {
        EList<EObject> _eContents_2 = parent.eContents();
        EObject _get_1 = _eContents_2.get((i).intValue());
        return this.getScope(_get_1, ref);
      }
    }
    return null;
  }
  
  public IScope scope_function_vars(final vis_basis_qualifiers context, final EReference ref) {
    final EObject parent = context.eContainer();
    if ((parent instanceof VisBasis)) {
      final VisBasis basis = ((VisBasis) parent);
      InputOutput.<String>println("jer");
      out_dataset _assigned = basis.getAssigned();
      outputbase _out_base = _assigned.getOut_base();
      InputOutput.<outputbase>println(_out_base);
      InputOutput.<String>println("bib");
      out_dataset _assigned_1 = basis.getAssigned();
      outputbase _out_base_1 = _assigned_1.getOut_base();
      boolean _notEquals = (!Objects.equal(_out_base_1, null));
      if (_notEquals) {
        out_dataset _assigned_2 = basis.getAssigned();
        outputbase _out_base_2 = _assigned_2.getOut_base();
        final dataset origin = _out_base_2.getActions();
        EList<EObject> _eContents = origin.eContents();
        final Iterable<IEObjectDescription> list_1 = Scopes.scopedElementsFor(_eContents);
        out_dataset _assigned_3 = basis.getAssigned();
        EList<EObject> _eContents_1 = _assigned_3.eContents();
        final Iterable<IEObjectDescription> list_2 = Scopes.scopedElementsFor(_eContents_1);
        final Iterable<IEObjectDescription> list = Iterables.<IEObjectDescription>concat(list_1, list_2);
        return MapBasedScope.createScope(IScope.NULLSCOPE, list);
      } else {
        out_dataset _assigned_4 = basis.getAssigned();
        return this.getScope(_assigned_4, ref);
      }
    }
    return null;
  }
}
